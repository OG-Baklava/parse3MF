{"version":3,"sources":["../src/core/analyzer.ts","../src/core/parser.ts","../src/core/exporter.ts"],"names":["Vector3","JSZip","BufferGeometry","BufferAttribute","normalizeColor","slotNorm"],"mappings":"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","file":"core.cjs","sourcesContent":["import { BufferGeometry, Vector3 } from 'three'\nimport type { BoundingBox } from './types'\n\n/**\n * Calculate volume of a BufferGeometry using the signed-tetrahedron method.\n * @returns Volume in cm (assumes model units are mm).\n */\nexport function calculateVolume(geometry: BufferGeometry): number {\n  const position = geometry.attributes.position\n  if (!position) throw new Error('Geometry has no position attribute')\n\n  let volume = 0\n  const index = geometry.index\n\n  if (index) {\n    const arr = index.array as Uint32Array | Uint16Array\n    for (let i = 0; i < index.count; i += 3) {\n      volume += signedVolumeOfTriangle(\n        new Vector3(position.getX(arr[i]), position.getY(arr[i]), position.getZ(arr[i])),\n        new Vector3(position.getX(arr[i + 1]), position.getY(arr[i + 1]), position.getZ(arr[i + 1])),\n        new Vector3(position.getX(arr[i + 2]), position.getY(arr[i + 2]), position.getZ(arr[i + 2])),\n      )\n    }\n  } else {\n    for (let i = 0; i < position.count; i += 3) {\n      volume += signedVolumeOfTriangle(\n        new Vector3(position.getX(i), position.getY(i), position.getZ(i)),\n        new Vector3(position.getX(i + 1), position.getY(i + 1), position.getZ(i + 1)),\n        new Vector3(position.getX(i + 2), position.getY(i + 2), position.getZ(i + 2)),\n      )\n    }\n  }\n\n  // mm  cm\n  return Math.abs(volume) / 1000\n}\n\nfunction signedVolumeOfTriangle(p1: Vector3, p2: Vector3, p3: Vector3): number {\n  return p1.dot(p2.cross(p3)) / 6.0\n}\n\n/**\n * Calculate bounding-box dimensions.\n * @returns { x, y, z } in mm.\n */\nexport function calculateBoundingBox(geometry: BufferGeometry): BoundingBox {\n  geometry.computeBoundingBox()\n  const box = geometry.boundingBox\n  if (!box) throw new Error('Failed to compute bounding box')\n  const size = new Vector3()\n  box.getSize(size)\n  return {\n    x: Number(size.x.toFixed(2)),\n    y: Number(size.y.toFixed(2)),\n    z: Number(size.z.toFixed(2)),\n  }\n}\n","/**\n * 3MF Parser  spec-compliant implementation (v2.7)\n *\n * Multicolor detection paths (checked in order):\n *  1. XML colorgroups/basematerials with triangle-level pid/p1 (standard 3MF)\n *  2. Bambu Studio: filament colors from JSON project_settings.config\n *  3. Bambu Studio: per-object/part extruder assignments from model_settings.config\n *  4. Bambu Studio: paint_color hex attributes on <triangle> elements (per-tri painting)\n *  5. Bambu Studio: filament count from JSON array lengths (e.g. 3-entry arrays = 3 filaments)\n *  6. PrusaSlicer: volume triangle ranges + per-volume extruder assignments\n *  7. Component-level pid/pindex from main model applied to external objects\n *  8. External object ID remapping with composite map fixup\n *\n * @packageDocumentation\n */\n\nimport { BufferGeometry, BufferAttribute } from 'three'\nimport type { ParsedThreeMF, MaterialSlot, Plate, ParsedTriangle, ParsedGeomObject } from './types'\nimport { calculateVolume, calculateBoundingBox } from './analyzer'\nimport JSZip from 'jszip'\n\n// ---------------------------------------------------------------------------\n// Errors\n// ---------------------------------------------------------------------------\n\n/** Thrown when a 3MF file cannot be parsed. */\nexport class ThreeMFParseError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'ThreeMFParseError'\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Internal Types\n// ---------------------------------------------------------------------------\n\ninterface PropertyResource {\n  id: string\n  type: 'basematerials' | 'colorgroup'\n  colors: string[]\n  names?: string[]\n}\n\ninterface BuildItem {\n  objectId: number\n  transform?: string\n}\n\ninterface ComponentRef {\n  objectId: number\n  path?: string\n  pid?: string\n  pindex?: number\n}\n\n// ---------------------------------------------------------------------------\n// XML Helper\n// ---------------------------------------------------------------------------\n\nfunction findElements(container: Document | Element, localName: string): Element[] {\n  const found = new Set<Element>()\n  const lowerName = localName.toLowerCase()\n\n  try {\n    container.querySelectorAll(localName).forEach(el => found.add(el))\n  } catch { /* ignore */ }\n\n  const allElements = container.getElementsByTagName('*')\n  for (let i = 0; i < allElements.length; i++) {\n    const elem = allElements[i]\n    const elemLocal = (elem.localName || '').toLowerCase()\n    const tagLower = elem.tagName.toLowerCase()\n    if (elemLocal === lowerName || tagLower === lowerName || tagLower.endsWith(':' + lowerName)) {\n      found.add(elem)\n    }\n  }\n\n  return Array.from(found)\n}\n\nfunction normalizeColor(color: string): string {\n  if (!color || color.trim() === '') return '#808080'\n  let c = color.trim()\n  if (!c.startsWith('#')) c = '#' + c\n  if (c.length === 9) c = c.substring(0, 7) // strip alpha\n  return c.toUpperCase()\n}\n\n// ---------------------------------------------------------------------------\n// Resource Parsing\n// ---------------------------------------------------------------------------\n\nfunction parseResources(xmlDoc: Document | Element): Map<string, PropertyResource> {\n  const resources = new Map<string, PropertyResource>()\n\n  for (const bmElem of findElements(xmlDoc, 'basematerials')) {\n    const id = bmElem.getAttribute('id') || bmElem.getAttribute('Id') || ''\n    if (!id) continue\n    const colors: string[] = []\n    const names: string[] = []\n    for (const base of findElements(bmElem, 'base')) {\n      colors.push(normalizeColor(base.getAttribute('displaycolor') || base.getAttribute('DisplayColor') || ''))\n      names.push(base.getAttribute('name') || base.getAttribute('Name') || '')\n    }\n    if (colors.length > 0) resources.set(id, { id, type: 'basematerials', colors, names })\n  }\n\n  for (const cgElem of findElements(xmlDoc, 'colorgroup')) {\n    const id = cgElem.getAttribute('id') || cgElem.getAttribute('Id') || ''\n    if (!id) continue\n    const colors: string[] = []\n    for (const colorElem of findElements(cgElem, 'color')) {\n      const c = colorElem.getAttribute('color') || colorElem.getAttribute('Color') || ''\n      if (c) colors.push(normalizeColor(c))\n    }\n    if (colors.length > 0) resources.set(id, { id, type: 'colorgroup', colors })\n  }\n\n  return resources\n}\n\nfunction resolveColor(\n  pid: string | null | undefined,\n  pindex: number,\n  resources: Map<string, PropertyResource>,\n): string | null {\n  if (!pid) return null\n  const resource = resources.get(pid)\n  if (!resource) return null\n  if (pindex < 0 || pindex >= resource.colors.length) return null\n  return resource.colors[pindex]\n}\n\n// ---------------------------------------------------------------------------\n// Object Parsing\n// ---------------------------------------------------------------------------\n\nfunction parseGeometryObjects(\n  xmlDoc: Document | Element,\n  resources: Map<string, PropertyResource>,\n  defaultColor?: string | null,\n): ParsedGeomObject[] {\n  const objects: ParsedGeomObject[] = []\n\n  for (const objElem of findElements(xmlDoc, 'object')) {\n    const type = objElem.getAttribute('type')\n    if (type && type !== 'model') continue\n\n    const id = parseInt(objElem.getAttribute('id') || '0')\n    const name = objElem.getAttribute('name') || objElem.getAttribute('Name') || `Object ${id}`\n\n    const objPid = objElem.getAttribute('pid') || null\n    const objPindexStr = objElem.getAttribute('pindex')\n    const objPindex = objPindexStr !== null ? parseInt(objPindexStr) : 0\n    const objDefaultColor = resolveColor(objPid, objPindex, resources) || defaultColor || null\n\n    const meshElems = findElements(objElem, 'mesh')\n    if (meshElems.length === 0) continue\n\n    const meshElem = meshElems[0]\n    const vertices: number[] = []\n    for (const v of findElements(meshElem, 'vertex')) {\n      vertices.push(\n        parseFloat(v.getAttribute('x') || '0'),\n        parseFloat(v.getAttribute('y') || '0'),\n        parseFloat(v.getAttribute('z') || '0'),\n      )\n    }\n    if (vertices.length === 0) continue\n\n    const triangles: ParsedTriangle[] = []\n    for (const t of findElements(meshElem, 'triangle')) {\n      const v1 = parseInt(t.getAttribute('v1') || '0')\n      const v2 = parseInt(t.getAttribute('v2') || '0')\n      const v3 = parseInt(t.getAttribute('v3') || '0')\n\n      const triPid = t.getAttribute('pid') || null\n      const p1Str = t.getAttribute('p1')\n      let colorHex: string | null = null\n\n      if (triPid && p1Str !== null) {\n        colorHex = resolveColor(triPid, parseInt(p1Str), resources)\n      } else if (triPid) {\n        colorHex = resolveColor(triPid, 0, resources)\n      }\n      if (!colorHex && objDefaultColor) colorHex = objDefaultColor\n\n      // Read BambuStudio paint_color / mmu_segmentation attribute\n      let paintAttr =\n        t.getAttribute('paint_color') ||\n        t.getAttribute('slic3rpe:mmu_segmentation') ||\n        t.getAttribute('mmu_segmentation') ||\n        null\n      if (!paintAttr) {\n        for (let ai = 0; ai < t.attributes.length; ai++) {\n          const aName = t.attributes[ai].name.toLowerCase()\n          if (aName.includes('paint_color') || aName.includes('mmu_segmentation')) {\n            paintAttr = t.attributes[ai].value\n            break\n          }\n        }\n      }\n\n      triangles.push({ v1, v2, v3, colorHex, paintAttr: paintAttr || undefined })\n    }\n\n    if (vertices.length > 0 && triangles.length > 0) {\n      objects.push({ id, name, vertices, triangles })\n    }\n  }\n\n  return objects\n}\n\nfunction parseComponents(objElem: Element): ComponentRef[] {\n  const components: ComponentRef[] = []\n  const seen = new Set<Element>()\n\n  const compElems = [\n    ...Array.from(objElem.querySelectorAll('components > component')),\n    ...findElements(objElem, 'component'),\n  ]\n\n  for (const comp of compElems) {\n    if (seen.has(comp)) continue\n    seen.add(comp)\n\n    const objectId = parseInt(comp.getAttribute('objectid') || '0')\n    if (objectId <= 0) continue\n\n    let path: string | undefined\n    for (let i = 0; i < comp.attributes.length; i++) {\n      const attr = comp.attributes[i]\n      if (attr.localName === 'path' || attr.name.endsWith(':path')) {\n        path = attr.value\n        break\n      }\n    }\n\n    const pid = comp.getAttribute('pid') || undefined\n    const pindex = pid ? parseInt(comp.getAttribute('pindex') || '0') : undefined\n\n    components.push({ objectId, path, pid, pindex })\n  }\n\n  return components\n}\n\n// ---------------------------------------------------------------------------\n// Bambu Studio / Slicer Metadata\n// ---------------------------------------------------------------------------\n\nasync function extractFilamentColors(\n  zipContent: JSZip,\n): Promise<{ colors: string[]; filamentCount: number }> {\n  let filamentCount = 0\n\n  // Source 1: project_settings.config (JSON in Bambu Studio)\n  for (const path of ['Metadata/project_settings.config', 'Metadata/Project_settings.config']) {\n    const file = zipContent.file(path)\n    if (!file) continue\n    try {\n      const content = await file.async('text')\n      const trimmed = content.trim()\n\n      if (trimmed.startsWith('{')) {\n        try {\n          const json = JSON.parse(trimmed)\n          for (const key of Object.keys(json)) {\n            if (Array.isArray(json[key]) && json[key].length > 1) {\n              filamentCount = Math.max(filamentCount, json[key].length)\n            }\n          }\n\n          const colorKey = Object.keys(json).find(\n            (k) => k.toLowerCase() === 'filament_colour' || k.toLowerCase() === 'filament_color',\n          )\n\n          if (colorKey) {\n            let rawColors: string[] = []\n            const val = json[colorKey]\n            if (Array.isArray(val)) {\n              rawColors = val.map((c: string) => String(c).trim()).filter((c: string) => c.length > 0)\n            } else if (typeof val === 'string') {\n              rawColors = val\n                .split(';')\n                .map((c: string) => c.trim())\n                .filter((c: string) => c.length > 0)\n            }\n            const colors = rawColors.map((c) => normalizeColor(c))\n            if (colors.length > 0)\n              return { colors, filamentCount: Math.max(filamentCount, colors.length) }\n          }\n\n          if (filamentCount > 1) return { colors: [], filamentCount }\n        } catch {\n          /* try INI fallback */\n        }\n      }\n\n      const match = content.match(/filament_colou?r\\s*=\\s*(.+)/i)\n      if (match) {\n        const raw = match[1]\n          .split(';')\n          .map((c) => c.trim())\n          .filter((c) => c.length > 0)\n        const colors = raw.map((c) => normalizeColor(c))\n        if (colors.length > 0) return { colors, filamentCount: Math.max(filamentCount, colors.length) }\n      }\n    } catch {\n      /* ignore */\n    }\n  }\n\n  // Source 2: slice_info.config\n  const sliceInfoFile = zipContent.file('Metadata/slice_info.config')\n  if (sliceInfoFile) {\n    try {\n      const content = await sliceInfoFile.async('text')\n      const parser = new DOMParser()\n      const doc = parser.parseFromString(content, 'text/xml')\n      const colors: string[] = []\n      for (const f of findElements(doc, 'filament')) {\n        const c = f.getAttribute('color') || f.getAttribute('Color') || ''\n        if (c && c.trim()) colors.push(normalizeColor(c))\n      }\n      const unique = [...new Set(colors)]\n      if (unique.length > 0) return { colors: unique, filamentCount: Math.max(filamentCount, unique.length) }\n    } catch {\n      /* ignore */\n    }\n  }\n\n  // Source 3: Any other .config file\n  const configFiles = Object.keys(zipContent.files).filter(\n    (f) => f.endsWith('.config') && !f.includes('model_settings'),\n  )\n  for (const path of configFiles) {\n    try {\n      const content = await zipContent.file(path)?.async('text')\n      if (!content) continue\n      const trimmed = content.trim()\n      if (trimmed.startsWith('{')) {\n        try {\n          const json = JSON.parse(trimmed)\n          const colorKey = Object.keys(json).find(\n            (k) => k.toLowerCase() === 'filament_colour' || k.toLowerCase() === 'filament_color',\n          )\n          if (colorKey) {\n            let rawColors: string[] = []\n            const val = json[colorKey]\n            if (Array.isArray(val)) {\n              rawColors = val.map((c: string) => String(c).trim()).filter((c: string) => c.length > 0)\n            } else if (typeof val === 'string') {\n              rawColors = val.split(';').map((c: string) => c.trim()).filter((c: string) => c.length > 0)\n            }\n            const colors = rawColors.map((c) => normalizeColor(c))\n            if (colors.length > 0) return { colors, filamentCount: Math.max(filamentCount, colors.length) }\n          }\n        } catch {\n          /* ignore */\n        }\n      }\n      const match = content.match(/filament_colou?r\\s*=\\s*(.+)/i)\n      if (match) {\n        const raw = match[1].split(';').map((c) => c.trim()).filter((c) => c.length > 0)\n        const colors = raw.map((c) => normalizeColor(c))\n        if (colors.length > 0) return { colors, filamentCount: Math.max(filamentCount, colors.length) }\n      }\n    } catch {\n      /* ignore */\n    }\n  }\n\n  return { colors: [], filamentCount }\n}\n\nasync function parseModelSettings(\n  zipContent: JSZip,\n): Promise<{\n  objectExtruderMap: Map<number, number>\n  hasMmuSegmentation: boolean\n  distinctExtruders: Set<number>\n}> {\n  const objectExtruderMap = new Map<number, number>()\n  let hasMmuSegmentation = false\n  const distinctExtruders = new Set<number>()\n\n  const modelSettingsFile = zipContent.file('Metadata/model_settings.config')\n  if (!modelSettingsFile) return { objectExtruderMap, hasMmuSegmentation, distinctExtruders }\n\n  try {\n    const content = await modelSettingsFile.async('text')\n    const parser = new DOMParser()\n    const configDoc = parser.parseFromString(content, 'text/xml')\n    const configObjects = findElements(configDoc, 'object')\n\n    for (const obj of configObjects) {\n      const objId = parseInt(obj.getAttribute('id') || '0')\n      if (objId <= 0) continue\n\n      const allObjMeta = new Map<string, string>()\n      const partMeta = new Set<Element>()\n\n      const parts = findElements(obj, 'part')\n      for (const part of parts) {\n        for (const meta of findElements(part, 'metadata')) {\n          partMeta.add(meta)\n          const key = meta.getAttribute('key') || ''\n          const value = meta.getAttribute('value') || meta.textContent?.trim() || ''\n          if (key === 'mmu_segmentation' && value.length > 0) hasMmuSegmentation = true\n        }\n      }\n\n      for (const meta of findElements(obj, 'metadata')) {\n        if (partMeta.has(meta)) continue\n        const key = meta.getAttribute('key') || ''\n        const value = meta.getAttribute('value') || meta.textContent?.trim() || ''\n        allObjMeta.set(key, value)\n        if (key === 'mmu_segmentation' && value.length > 0) hasMmuSegmentation = true\n      }\n\n      // Process parts (most specific)\n      for (const part of parts) {\n        const subObjId = parseInt(part.getAttribute('sub_object_id') || '0')\n        const partIdAttr = parseInt(part.getAttribute('id') || '0')\n        const targetId = subObjId || partIdAttr\n\n        const partMetaMap = new Map<string, string>()\n        for (const meta of findElements(part, 'metadata')) {\n          const key = meta.getAttribute('key') || ''\n          const value = meta.getAttribute('value') || meta.textContent?.trim() || ''\n          partMetaMap.set(key, value)\n        }\n\n        // Check child elements\n        for (const childTag of ['paint_color', 'mmu_segmentation']) {\n          if (findElements(part, childTag).length > 0) hasMmuSegmentation = true\n        }\n\n        if (targetId <= 0) continue\n\n        const extruderStr = partMetaMap.get('extruder')\n        if (extruderStr !== undefined) {\n          const extruder = parseInt(extruderStr)\n          if (!isNaN(extruder) && extruder >= 0) {\n            const effectiveExtruder = extruder === 0 ? 1 : extruder\n            objectExtruderMap.set(targetId, effectiveExtruder)\n            distinctExtruders.add(effectiveExtruder)\n          }\n        }\n      }\n\n      // Object-level extruder (fallback)\n      const objExtruderStr = allObjMeta.get('extruder')\n      if (objExtruderStr !== undefined) {\n        const objExtruder = parseInt(objExtruderStr)\n        if (!isNaN(objExtruder) && objExtruder >= 0) {\n          const effectiveExtruder = objExtruder === 0 ? 1 : objExtruder\n          if (!objectExtruderMap.has(objId)) {\n            objectExtruderMap.set(objId, effectiveExtruder)\n            distinctExtruders.add(effectiveExtruder)\n          }\n          for (const part of parts) {\n            const subObjId = parseInt(part.getAttribute('sub_object_id') || '0')\n            const partIdAttr = parseInt(part.getAttribute('id') || '0')\n            const targetId = subObjId || partIdAttr\n            if (targetId > 0 && !objectExtruderMap.has(targetId)) {\n              objectExtruderMap.set(targetId, effectiveExtruder)\n              distinctExtruders.add(effectiveExtruder)\n            }\n          }\n        }\n      }\n    }\n\n    return { objectExtruderMap, hasMmuSegmentation, distinctExtruders }\n  } catch {\n    return { objectExtruderMap, hasMmuSegmentation, distinctExtruders }\n  }\n}\n\nasync function parseBambuPlates(\n  zipContent: JSZip,\n): Promise<{ plates: Plate[]; plateObjectMap: Map<number, number[]> }> {\n  const plates: Plate[] = []\n  const plateObjectMap = new Map<number, number[]>()\n\n  const plateFiles = Object.keys(zipContent.files)\n    .filter((f) => /Metadata\\/plate_\\d+\\.json/i.test(f))\n    .sort()\n\n  if (plateFiles.length > 0) {\n    for (const platePath of plateFiles) {\n      try {\n        const content = await zipContent.file(platePath)?.async('text')\n        if (!content) continue\n        const plateData = JSON.parse(content)\n        const plateNum = parseInt(platePath.match(/plate_(\\d+)/)?.[1] || '0')\n        if (plateNum <= 0) continue\n\n        const objectIds: number[] = []\n        if (Array.isArray(plateData)) {\n          plateData.forEach((item: any) => {\n            if (item.id !== undefined) objectIds.push(item.id)\n          })\n        } else if (plateData.objects) {\n          plateData.objects.forEach((item: any) => {\n            if (item.id !== undefined) objectIds.push(item.id)\n          })\n        }\n\n        plates.push({ id: plateNum, name: `Plate ${plateNum}`, objectIds })\n        plateObjectMap.set(plateNum, objectIds)\n      } catch {\n        /* ignore */\n      }\n    }\n  }\n\n  if (plates.length === 0) {\n    const filamentSeqFile = zipContent.file('Metadata/filament_sequence.json')\n    if (filamentSeqFile) {\n      try {\n        const content = await filamentSeqFile.async('text')\n        const seq = JSON.parse(content)\n        const plateKeys = Object.keys(seq).filter((k) => k.startsWith('plate_'))\n        for (const key of plateKeys) {\n          const plateNum = parseInt(key.replace('plate_', '')) || 0\n          if (plateNum > 0) {\n            plates.push({ id: plateNum, name: `Plate ${plateNum}`, objectIds: [] })\n            plateObjectMap.set(plateNum, [])\n          }\n        }\n      } catch {\n        /* ignore */\n      }\n    }\n  }\n\n  return { plates, plateObjectMap }\n}\n\nasync function parsePrusaSlicerMetadata(\n  zipContent: JSZip,\n): Promise<{\n  volumeRanges: Array<{ firstid: number; lastid: number; extruder: number }>\n  extruderColors: string[]\n}> {\n  const volumeRanges: Array<{ firstid: number; lastid: number; extruder: number }> = []\n  const extruderColors: string[] = []\n\n  const configFiles = Object.keys(zipContent.files).filter(\n    (f) => f.includes('Slic3r') && f.endsWith('.config'),\n  )\n  if (configFiles.length === 0) return { volumeRanges, extruderColors }\n\n  const modelConfigFile = configFiles.find((f) => f.includes('model'))\n  if (modelConfigFile) {\n    try {\n      const content = await zipContent.file(modelConfigFile)?.async('text')\n      if (content) {\n        const parser = new DOMParser()\n        const configDoc = parser.parseFromString(content, 'text/xml')\n        configDoc.querySelectorAll('volume').forEach((volume) => {\n          const firstid = parseInt(volume.getAttribute('firstid') || '-1')\n          const lastid = parseInt(volume.getAttribute('lastid') || '-1')\n          if (firstid < 0 || lastid < 0) return\n          let extruder = 1\n          for (const meta of Array.from(volume.querySelectorAll('metadata'))) {\n            if (meta.getAttribute('key') === 'extruder') {\n              extruder = parseInt(meta.getAttribute('value') || meta.textContent || '1')\n            }\n          }\n          volumeRanges.push({ firstid, lastid, extruder })\n        })\n      }\n    } catch {\n      /* ignore */\n    }\n  }\n\n  for (const configFile of configFiles) {\n    if (configFile === modelConfigFile) continue\n    try {\n      const content = await zipContent.file(configFile)?.async('text')\n      if (!content) continue\n      const match = content.match(/extruder_colou?r\\s*=\\s*(.+)/i)\n      if (match) {\n        extruderColors.push(...match[1].split(';').map((c) => normalizeColor(c.trim())))\n        break\n      }\n    } catch {\n      /* ignore */\n    }\n  }\n\n  return { volumeRanges, extruderColors }\n}\n\n// ---------------------------------------------------------------------------\n// Paint Color / MMU Segmentation Decoder\n// ---------------------------------------------------------------------------\n\nfunction paintHexToBits(hexStr: string): number[] {\n  const bits: number[] = []\n  for (let i = hexStr.length - 1; i >= 0; i--) {\n    const ch = hexStr.charCodeAt(i)\n    let dec = 0\n    if (ch >= 48 && ch <= 57) dec = ch - 48\n    else if (ch >= 65 && ch <= 70) dec = 10 + ch - 65\n    else if (ch >= 97 && ch <= 102) dec = 10 + ch - 97\n    for (let b = 0; b < 4; b++) bits.push((dec >> b) & 1)\n  }\n  return bits\n}\n\nfunction decodePaintTreeNode(bits: number[], pos: { i: number }, depth: number): number {\n  if (pos.i + 1 >= bits.length || depth > 20) return 0\n\n  const splitSides = bits[pos.i] + bits[pos.i + 1] * 2\n  pos.i += 2\n\n  if (splitSides > 0) {\n    if (pos.i + 1 >= bits.length) return 0\n    pos.i += 2 // skip special_side\n\n    const childStates: number[] = []\n    for (let c = splitSides; c >= 0; c--) {\n      childStates.push(decodePaintTreeNode(bits, pos, depth + 1))\n    }\n\n    const counts = new Map<number, number>()\n    for (const s of childStates) {\n      if (s > 0) counts.set(s, (counts.get(s) || 0) + 1)\n    }\n    let best = 0,\n      bestCount = 0\n    counts.forEach((count, state) => {\n      if (count > bestCount) {\n        bestCount = count\n        best = state\n      }\n    })\n    return best\n  } else {\n    if (pos.i + 1 >= bits.length) return 0\n    const xx = bits[pos.i] + bits[pos.i + 1] * 2\n    pos.i += 2\n\n    if (xx < 3) return xx\n\n    let n = 0\n    while (pos.i + 3 < bits.length) {\n      let nibble = 0\n      for (let b = 0; b < 4; b++) nibble |= bits[pos.i + b] << b\n      pos.i += 4\n      if (nibble === 15) {\n        n += 15\n      } else {\n        n += nibble\n        break\n      }\n    }\n    return 3 + n\n  }\n}\n\nfunction decodePaintColorAttr(hexStr: string): number {\n  if (!hexStr || hexStr.length === 0) return 0\n  const bits = paintHexToBits(hexStr)\n  const pos = { i: 0 }\n  return decodePaintTreeNode(bits, pos, 0)\n}\n\n// ---------------------------------------------------------------------------\n// Main Parser\n// ---------------------------------------------------------------------------\n\n/**\n * Parse a `.3MF` file into geometry, colors, plates, and material slots.\n *\n * Works with files exported from **Bambu Studio**, **PrusaSlicer**, **Cura**,\n * and any other slicer that follows the 3MF Core Specification.\n *\n * @param file  A `File` object (e.g. from an `<input type=\"file\">`)\n * @returns     A {@link ParsedThreeMF} containing everything needed to render\n *              the model.\n *\n * @example\n * ```ts\n * import { parse3MF } from 'parse3mf/core'\n *\n * const result = await parse3MF(myFile)\n * console.log(result.isMultiColor) // true\n * console.log(result.materialSlots) // [{ id: '#FF0000', name: 'Color 1', ... }, ...]\n * ```\n */\nexport async function parse3MF(file: File): Promise<ParsedThreeMF> {\n  try {\n    const arrayBuffer = await file.arrayBuffer()\n    const zip = new JSZip()\n    const zipContent = await zip.loadAsync(arrayBuffer)\n    const zipFiles = Object.keys(zipContent.files)\n\n    // -----------------------------------------------------------------------\n    // Step 1: Find main model file\n    // -----------------------------------------------------------------------\n    let mainModelPath = '3D/3dmodel.model'\n    let mainModelFile = zipContent.file(mainModelPath)\n    if (!mainModelFile) {\n      mainModelPath = '3D/3dModel.model'\n      mainModelFile = zipContent.file(mainModelPath)\n    }\n    if (!mainModelFile) {\n      const modelFiles = zipFiles.filter((f) => f.endsWith('.model') && f.startsWith('3D/'))\n      if (modelFiles.length > 0) {\n        mainModelPath = modelFiles[0]\n        mainModelFile = zipContent.file(mainModelPath)\n      }\n    }\n    if (!mainModelFile) throw new ThreeMFParseError('Invalid .3MF file: no model file found')\n\n    const mainXML = await mainModelFile.async('text')\n    const domParser = new DOMParser()\n    const mainDoc = domParser.parseFromString(mainXML, 'text/xml')\n\n    // -----------------------------------------------------------------------\n    // Step 2: Parse resources\n    // -----------------------------------------------------------------------\n    const mainResources = parseResources(mainDoc)\n\n    // -----------------------------------------------------------------------\n    // Step 3: Build section + composites\n    // -----------------------------------------------------------------------\n    const buildItems: BuildItem[] = []\n    const buildElems = findElements(mainDoc, 'build')\n    if (buildElems.length > 0) {\n      for (const item of findElements(buildElems[0], 'item')) {\n        const objectId = parseInt(item.getAttribute('objectid') || '0')\n        if (objectId > 0) {\n          buildItems.push({ objectId, transform: item.getAttribute('transform') || undefined })\n        }\n      }\n    }\n\n    const compositeToGeometryMap = new Map<number, number[]>()\n    const componentColorOverrides = new Map<number, string>()\n\n    for (const objElem of findElements(mainDoc, 'object')) {\n      const objId = parseInt(objElem.getAttribute('id') || '0')\n      if (objId <= 0) continue\n\n      const components = parseComponents(objElem)\n      if (components.length === 0) continue\n\n      const geomIds: number[] = []\n      for (const comp of components) {\n        geomIds.push(comp.objectId)\n        if (comp.pid) {\n          const overrideColor = resolveColor(comp.pid, comp.pindex || 0, mainResources)\n          if (overrideColor) componentColorOverrides.set(comp.objectId, overrideColor)\n        }\n      }\n      compositeToGeometryMap.set(objId, geomIds)\n    }\n\n    // -----------------------------------------------------------------------\n    // Step 4: Parse ALL geometry objects\n    // -----------------------------------------------------------------------\n    let allGeomObjects: ParsedGeomObject[] = []\n\n    const mainGeomObjects = parseGeometryObjects(mainDoc, mainResources)\n    allGeomObjects.push(...mainGeomObjects)\n\n    const externalObjectFiles = zipFiles\n      .filter((f) => f.startsWith('3D/Objects/') && f.endsWith('.model'))\n      .sort()\n\n    const externalIdRemap = new Map<number, number>()\n\n    if (externalObjectFiles.length > 0) {\n      const mainGeomIds = new Set(mainGeomObjects.map((o) => o.id))\n\n      for (const filePath of externalObjectFiles) {\n        const fileIdMatch = filePath.match(/object_(\\d+)\\.model/)\n        const fileId = fileIdMatch ? parseInt(fileIdMatch[1]) : 0\n        if (mainGeomIds.has(fileId)) continue\n\n        const extFile = zipContent.file(filePath)\n        if (!extFile) continue\n\n        const xml = await extFile.async('text')\n        const doc = domParser.parseFromString(xml, 'text/xml')\n\n        const fileResources = parseResources(doc)\n        let componentOverride = componentColorOverrides.get(fileId) || null\n        if (!componentOverride) {\n          for (const [compObjId, color] of componentColorOverrides) {\n            if (compositeToGeometryMap.has(compObjId)) continue\n            componentOverride = color\n            break\n          }\n        }\n\n        const mergedResources = new Map(mainResources)\n        fileResources.forEach((res, id) => mergedResources.set(id, res))\n\n        const fileObjects = parseGeometryObjects(doc, mergedResources, componentOverride)\n\n        for (const obj of fileObjects) {\n          const mappedId = fileObjects.length === 1 && fileId > 0 ? fileId : obj.id\n          allGeomObjects.push({ ...obj, id: mappedId, sourceFile: filePath })\n          if (mappedId !== obj.id) externalIdRemap.set(obj.id, mappedId)\n        }\n      }\n    }\n\n    // Fix composite map with remapped IDs\n    if (externalIdRemap.size > 0) {\n      compositeToGeometryMap.forEach((geomIds, compositeId) => {\n        compositeToGeometryMap.set(\n          compositeId,\n          geomIds.map((id) => externalIdRemap.get(id) ?? id),\n        )\n      })\n    }\n\n    if (allGeomObjects.length === 0) {\n      throw new ThreeMFParseError('No geometry objects found in 3MF file')\n    }\n\n    // -----------------------------------------------------------------------\n    // Step 5: Slicer-specific coloring\n    // -----------------------------------------------------------------------\n\n    // 5a: Bambu Studio extruder assignments\n    const modelSettings = await parseModelSettings(zipContent)\n\n    // Scan model files for painting keywords\n    const allModelFiles = zipFiles.filter((f) => f.endsWith('.model'))\n    for (const modelPath of allModelFiles) {\n      try {\n        const modelFile = zipContent.file(modelPath)\n        if (!modelFile) continue\n        const xml = await modelFile.async('text')\n        const paintingKeywords = ['mmu_segmentation', 'paint_color', 'mmu_painting', 'FacePainting', 'face_property']\n        for (const keyword of paintingKeywords) {\n          if (xml.includes(keyword)) modelSettings.hasMmuSegmentation = true\n        }\n      } catch {\n        /* ignore */\n      }\n    }\n\n    const filamentData = await extractFilamentColors(zipContent)\n    const filamentColors = filamentData.colors\n    const filamentCount = filamentData.filamentCount\n    const hasMultipleExtruders = modelSettings.distinctExtruders.size > 1\n    const hasMultipleFilaments = filamentCount > 1\n\n    // Apply extruder-based coloring\n    if (modelSettings.objectExtruderMap.size > 0 && filamentColors.length > 0) {\n      allGeomObjects.forEach((obj) => {\n        let extruder = modelSettings.objectExtruderMap.get(obj.id)\n        if (extruder === undefined) {\n          compositeToGeometryMap.forEach((geomIds, compositeId) => {\n            if (geomIds.includes(obj.id)) {\n              const cExt = modelSettings.objectExtruderMap.get(compositeId)\n              if (cExt !== undefined) extruder = cExt\n            }\n          })\n        }\n        if (extruder === undefined && obj.sourceFile) {\n          const fMatch = obj.sourceFile.match(/object_(\\d+)\\.model/)\n          const fId = fMatch ? parseInt(fMatch[1]) : 0\n          if (fId > 0 && fId !== obj.id) extruder = modelSettings.objectExtruderMap.get(fId)\n        }\n        if (extruder !== undefined && extruder > 0 && extruder <= filamentColors.length) {\n          const color = filamentColors[extruder - 1]\n          if (!obj.triangles.some((t) => t.colorHex !== null)) {\n            obj.triangles.forEach((t) => { t.colorHex = color })\n          }\n        }\n      })\n    }\n\n    // 5b: PrusaSlicer volume mapping\n    const prusaData = await parsePrusaSlicerMetadata(zipContent)\n    if (prusaData.volumeRanges.length > 0 && prusaData.extruderColors.length > 0) {\n      let globalTriOffset = 0\n      allGeomObjects.forEach((obj) => {\n        if (obj.triangles.some((t) => t.colorHex !== null)) {\n          globalTriOffset += obj.triangles.length\n          return\n        }\n        for (let i = 0; i < obj.triangles.length; i++) {\n          const globalIdx = globalTriOffset + i\n          for (const range of prusaData.volumeRanges) {\n            if (globalIdx >= range.firstid && globalIdx <= range.lastid) {\n              const color = prusaData.extruderColors[range.extruder - 1]\n              if (color) obj.triangles[i].colorHex = color\n              break\n            }\n          }\n        }\n        globalTriOffset += obj.triangles.length\n      })\n    }\n\n    // 5c: Paint data attributes\n    if (filamentColors.length >= 1) {\n      for (const obj of allGeomObjects) {\n        if (!obj.triangles.some((t) => t.paintAttr)) continue\n\n        let defaultColor = filamentColors[0]\n        let objExtruder = modelSettings.objectExtruderMap.get(obj.id)\n        if (objExtruder === undefined) {\n          compositeToGeometryMap.forEach((geomIds, compositeId) => {\n            if (geomIds.includes(obj.id)) {\n              const cExt = modelSettings.objectExtruderMap.get(compositeId)\n              if (cExt !== undefined) objExtruder = cExt\n            }\n          })\n        }\n        if (objExtruder !== undefined && objExtruder > 0 && objExtruder <= filamentColors.length) {\n          defaultColor = filamentColors[objExtruder - 1]\n        }\n\n        for (const tri of obj.triangles) {\n          if (tri.paintAttr) {\n            const state = decodePaintColorAttr(tri.paintAttr)\n            if (state > 0 && state <= filamentColors.length) {\n              tri.colorHex = filamentColors[state - 1]\n            } else if (state > 0) {\n              tri.colorHex = filamentColors[filamentColors.length - 1]\n            } else {\n              tri.colorHex = defaultColor\n            }\n          } else if (tri.colorHex === null) {\n            tri.colorHex = defaultColor\n          }\n        }\n      }\n    }\n\n    // 5d: Fallback sequential coloring\n    const totalColoredTriangles = allGeomObjects.reduce(\n      (sum, obj) => sum + obj.triangles.filter((t) => t.colorHex !== null).length,\n      0,\n    )\n    if (totalColoredTriangles === 0 && filamentColors.length > 1 && allGeomObjects.length > 1) {\n      if (modelSettings.hasMmuSegmentation || hasMultipleExtruders) {\n        allGeomObjects.forEach((obj, idx) => {\n          const color = filamentColors[idx % filamentColors.length]\n          obj.triangles.forEach((t) => { t.colorHex = color })\n        })\n      }\n    }\n\n    // -----------------------------------------------------------------------\n    // Step 6: Create BufferGeometries\n    // -----------------------------------------------------------------------\n    const geometries: BufferGeometry[] = []\n    const objectIdToGeometryIndex = new Map<number, number>()\n    const triangleMaterialMaps = new Map<number, Map<number, string>>()\n    const allUniqueColors = new Set<string>()\n    let totalVolume = 0\n    let globalBoundingBox = { x: 0, y: 0, z: 0 }\n\n    for (let i = 0; i < allGeomObjects.length; i++) {\n      const obj = allGeomObjects[i]\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', new BufferAttribute(new Float32Array(obj.vertices), 3))\n\n      const indices = new Uint32Array(obj.triangles.length * 3)\n      const triColorMap = new Map<number, string>()\n      let hasAnyColor = false\n\n      for (let t = 0; t < obj.triangles.length; t++) {\n        const tri = obj.triangles[t]\n        indices[t * 3] = tri.v1\n        indices[t * 3 + 1] = tri.v2\n        indices[t * 3 + 2] = tri.v3\n        if (tri.colorHex) {\n          triColorMap.set(t, tri.colorHex)\n          allUniqueColors.add(tri.colorHex)\n          hasAnyColor = true\n        }\n      }\n\n      geometry.setIndex(new BufferAttribute(indices, 1))\n      geometry.computeVertexNormals()\n      geometries.push(geometry)\n      objectIdToGeometryIndex.set(obj.id, i)\n      if (hasAnyColor) triangleMaterialMaps.set(i, triColorMap)\n\n      try {\n        totalVolume += calculateVolume(geometry)\n        const bbox = calculateBoundingBox(geometry)\n        globalBoundingBox.x = Math.max(globalBoundingBox.x, bbox.x)\n        globalBoundingBox.y = Math.max(globalBoundingBox.y, bbox.y)\n        globalBoundingBox.z = Math.max(globalBoundingBox.z, bbox.z)\n      } catch {\n        /* skip */\n      }\n    }\n\n    // Map composite IDs\n    compositeToGeometryMap.forEach((geomIds, compositeId) => {\n      if (!objectIdToGeometryIndex.has(compositeId)) {\n        const firstIdx = objectIdToGeometryIndex.get(geomIds[0])\n        if (firstIdx !== undefined) objectIdToGeometryIndex.set(compositeId, firstIdx)\n      }\n    })\n\n    // -----------------------------------------------------------------------\n    // Step 7: Material slots\n    // -----------------------------------------------------------------------\n    const colorArray = Array.from(allUniqueColors).sort()\n    const materialSlots: MaterialSlot[] = []\n\n    const isMultiColorFromColors = colorArray.length > 1\n    const isMultiColorFromExtruders = hasMultipleExtruders && filamentColors.length > 1\n    const isMultiColorFromPainting = modelSettings.hasMmuSegmentation\n    const isMultiColorFromPrusa =\n      prusaData.volumeRanges.length > 0 && new Set(prusaData.volumeRanges.map((r) => r.extruder)).size > 1\n    const isMultiColorFromFilamentConfig = hasMultipleFilaments || filamentColors.length > 1\n    const isMultiColor =\n      isMultiColorFromColors ||\n      isMultiColorFromExtruders ||\n      isMultiColorFromPainting ||\n      isMultiColorFromPrusa ||\n      isMultiColorFromFilamentConfig\n\n    if (colorArray.length > 1) {\n      colorArray.forEach((colorHex, idx) => {\n        const objectIds: number[] = []\n        triangleMaterialMaps.forEach((triMap, geomIdx) => {\n          for (const c of triMap.values()) {\n            if (c === colorHex) {\n              objectIds.push(geomIdx)\n              break\n            }\n          }\n        })\n        if (objectIds.length === 0) objectIds.push(...geometries.map((_, i) => i))\n        materialSlots.push({ id: colorHex, name: `Color ${idx + 1}`, objectIds, selectedColor: colorHex })\n      })\n    } else if (filamentColors.length > 1) {\n      filamentColors.forEach((color, idx) => {\n        const objectIds: number[] = []\n        allGeomObjects.forEach((obj, geomIdx) => {\n          if (obj.triangles.length > 0 && obj.triangles[0].colorHex === color) objectIds.push(geomIdx)\n        })\n        if (objectIds.length === 0) objectIds.push(...geometries.map((_, i) => i))\n        materialSlots.push({ id: color, name: `Filament ${idx + 1}`, objectIds, selectedColor: color })\n      })\n    } else if (filamentCount > 1 && filamentColors.length === 0) {\n      const defaultSlotColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FF8000', '#8000FF']\n      for (let i = 0; i < filamentCount; i++) {\n        const slotColor =\n          i < defaultSlotColors.length\n            ? defaultSlotColors[i]\n            : `#${((i * 37) % 256).toString(16).padStart(2, '0')}80FF`\n        materialSlots.push({\n          id: `filament_${i + 1}`,\n          name: `Filament ${i + 1}`,\n          objectIds: geometries.map((_, gi) => gi),\n          selectedColor: slotColor,\n        })\n      }\n    } else if (isMultiColor && prusaData.extruderColors.length > 1) {\n      prusaData.extruderColors.forEach((color, idx) => {\n        materialSlots.push({\n          id: color,\n          name: `Extruder ${idx + 1}`,\n          objectIds: geometries.map((_, i) => i),\n          selectedColor: color,\n        })\n      })\n    } else {\n      materialSlots.push({\n        id: 'default',\n        name: 'Material 1',\n        objectIds: geometries.map((_, i) => i),\n        selectedColor: '#FFFFFF',\n      })\n    }\n\n    // -----------------------------------------------------------------------\n    // Step 8: Plates\n    // -----------------------------------------------------------------------\n    let { plates, plateObjectMap } = await parseBambuPlates(zipContent)\n\n    if (plates.length > 0) {\n      const hasEmpty = plates.some((p) => p.objectIds.length === 0)\n      if (hasEmpty) {\n        const allIds = buildItems.length > 0 ? buildItems.map((b) => b.objectId) : allGeomObjects.map((o) => o.id)\n        plates.forEach((p) => {\n          if (p.objectIds.length === 0) {\n            p.objectIds = [...allIds]\n            plateObjectMap.set(p.id, [...allIds])\n          }\n        })\n      }\n    }\n\n    if (plates.length === 0) {\n      const allObjectIds = allGeomObjects.map((o) => o.id)\n      plates = [{ id: 1, name: 'Plate 1', objectIds: allObjectIds }]\n      plateObjectMap = new Map([[1, allObjectIds]])\n    }\n\n    return {\n      volume: totalVolume,\n      boundingBox: globalBoundingBox,\n      materialSlots,\n      isMultiColor,\n      metadata: {},\n      geometries,\n      triangleMaterialMaps: triangleMaterialMaps.size > 0 ? triangleMaterialMaps : undefined,\n      plates: plates.length > 0 ? plates : undefined,\n      plateObjectMap: plateObjectMap.size > 0 ? plateObjectMap : undefined,\n      objectIdToGeometryIndex: objectIdToGeometryIndex.size > 0 ? objectIdToGeometryIndex : undefined,\n      compositeToGeometryMap: compositeToGeometryMap.size > 0 ? compositeToGeometryMap : undefined,\n    }\n  } catch (error) {\n    if (error instanceof ThreeMFParseError) throw error\n    throw new ThreeMFParseError(\n      `Failed to parse .3MF file: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    )\n  }\n}\n","/**\n * 3MF Exporter  re-packages a .3MF file with **only** color values changed.\n *\n *  DESIGN PRINCIPLE: surgical, field-specific string replacements only.\n *   No DOM parsing / re-serialization. No JSON parse / stringify.\n *   Only the exact color hex values inside known color fields are touched.\n *   Every other byte of the original file is preserved exactly as-is.\n *   Safe for production 3D printing workflows.\n *\n * @packageDocumentation\n */\n\nimport JSZip from 'jszip'\nimport type { MaterialSlot, ColorOption } from './types'\n\n// ---------------------------------------------------------------------------\n// Color helpers\n// ---------------------------------------------------------------------------\n\nconst DEFAULT_COLOR_MAP: Record<string, string> = {\n  White: '#F1F5F9',\n  Black: '#1E293B',\n  Red: '#EF4444',\n  Blue: '#3B82F6',\n  Green: '#22C55E',\n  Yellow: '#EAB308',\n  Orange: '#F97316',\n  Grey: '#64748B',\n  Clear: '#E0F2FE',\n}\n\n/**\n * Resolve a user color selection to an uppercase hex string (#RRGGBB).\n * Accepts hex strings or named colors.\n */\nfunction resolveToHex(color: string, colorOptions?: ColorOption[]): string {\n  if (color.startsWith('#')) {\n    let c = color.toUpperCase()\n    if (c.length === 4) c = `#${c[1]}${c[1]}${c[2]}${c[2]}${c[3]}${c[3]}`\n    if (c.length === 9) c = c.substring(0, 7)\n    return c\n  }\n  if (colorOptions) {\n    const opt = colorOptions.find((o) => o.name === color)\n    if (opt) return opt.hex.toUpperCase()\n  }\n  const hex = DEFAULT_COLOR_MAP[color]\n  return hex ? hex.toUpperCase() : '#808080'\n}\n\n/** Normalize a color string to uppercase #RRGGBB (stripping alpha). */\nfunction normalizeColor(color: string): string {\n  if (!color || color.trim() === '') return '#808080'\n  let c = color.trim()\n  if (!c.startsWith('#')) c = '#' + c\n  if (c.length === 9) c = c.substring(0, 7)\n  return c.toUpperCase()\n}\n\n/**\n * Build a case-insensitive regex that matches a specific 6-digit hex color\n * (with optional 2-digit alpha suffix), ensuring no trailing hex chars.\n */\nfunction hexPattern(hex6: string): RegExp {\n  // hex6 is like \"#AABBCC\"  build pattern that matches case-insensitively\n  // and captures optional alpha suffix\n  const body = hex6.slice(1) // \"AABBCC\"\n  return new RegExp(\n    '#' + body + '([0-9a-fA-F]{2})?(?![0-9a-fA-F])',\n    'gi',\n  )\n}\n\n/** Replace a hex color in a string, preserving any alpha suffix. */\nfunction replaceHex(text: string, oldHex: string, newHex: string): string {\n  return text.replace(hexPattern(oldHex), (_match, alpha) => {\n    return newHex + (alpha || '')\n  })\n}\n\n// ---------------------------------------------------------------------------\n// Cross-referencing helpers: extract color values from different sources\n// so we can map between them when they don't exactly match.\n// ---------------------------------------------------------------------------\n\n/**\n * Extract the ordered list of filament colors from the project_settings\n * config file (JSON or INI format). Returns normalized hex values in\n * filament order. Returns [] if not found.\n */\nasync function extractConfigFilamentColors(zipContent: JSZip): Promise<string[]> {\n  for (const path of ['Metadata/project_settings.config', 'Metadata/Project_settings.config']) {\n    const file = zipContent.file(path)\n    if (!file) continue\n\n    try {\n      const content = await file.async('text')\n      const trimmed = content.trim()\n\n      if (trimmed.startsWith('{')) {\n        // JSON format\n        try {\n          const json = JSON.parse(trimmed)\n          const colorKey = Object.keys(json).find(\n            (k) => k.toLowerCase() === 'filament_colour' || k.toLowerCase() === 'filament_color',\n          )\n          if (colorKey) {\n            const val = json[colorKey]\n            if (Array.isArray(val)) {\n              return val.map((c: string) => normalizeColor(String(c)))\n            }\n            if (typeof val === 'string') {\n              return val\n                .split(';')\n                .map((c: string) => c.trim())\n                .filter((c: string) => c.length > 0)\n                .map((c) => normalizeColor(c))\n            }\n          }\n        } catch {\n          /* try INI fallback */\n        }\n      }\n\n      // INI format\n      const match = content.match(/filament_colou?r\\s*=\\s*(.+)/i)\n      if (match) {\n        return match[1]\n          .split(';')\n          .map((c) => c.trim())\n          .filter((c) => c.length > 0)\n          .map((c) => normalizeColor(c))\n      }\n    } catch {\n      continue\n    }\n  }\n\n  return []\n}\n\n/**\n * Extract ordered displaycolor values from `<base>` elements inside\n * `<basematerials>` blocks in model XML. Also extracts color values\n * from `<color>` elements inside `<colorgroup>` blocks.\n * Returns raw (unnormalized) strings as they appear in the file.\n */\nfunction extractXmlColorValues(xml: string): string[] {\n  const colors: string[] = []\n\n  // From <base ... displaycolor=\"VALUE\" ...>\n  const basePattern = /<base\\b[^>]*?displaycolor\\s*=\\s*[\"']([^\"']*?)[\"'][^>]*?>/gi\n  let match\n  while ((match = basePattern.exec(xml)) !== null) {\n    if (match[1]) colors.push(match[1])\n  }\n\n  // If we found basematerials colors, return them.\n  // Otherwise fall back to colorgroup colors.\n  if (colors.length > 0) return colors\n\n  const colorPattern = /<color\\b[^>]*?\\bcolor\\s*=\\s*[\"']([^\"']*?)[\"'][^>]*?>/gi\n  while ((match = colorPattern.exec(xml)) !== null) {\n    if (match[1]) colors.push(match[1])\n  }\n\n  return colors\n}\n\n/**\n * Build an expanded color remap for the model XML by cross-referencing\n * the config filament colors and the XML basematerials/colorgroup colors.\n *\n * If basematerials has #000000FF for filament 1 but the config has #FF0000FF,\n * and the primary remap (from slot IDs) maps #FF0000  #3B82F6, then we also\n * need to map #000000  #3B82F6 in the model XML. This function adds those\n * extra entries.\n */\nfunction buildModelRemap(\n  xml: string,\n  primaryRemap: Map<string, string>,\n  configColors: string[],\n  materialSlots: MaterialSlot[],\n  colorOptions?: ColorOption[],\n): Map<string, string> {\n  if (primaryRemap.size === 0) return primaryRemap\n\n  const expanded = new Map(primaryRemap)\n  const xmlColors = extractXmlColorValues(xml)\n\n  if (xmlColors.length === 0 || configColors.length === 0) return expanded\n\n  // For each filament position, cross-reference the XML color with the config color.\n  // If only one of them is in the remap, add the other with the same replacement.\n  const len = Math.min(xmlColors.length, configColors.length)\n  for (let i = 0; i < len; i++) {\n    const xmlNorm = normalizeColor(xmlColors[i])\n    const cfgNorm = configColors[i] // already normalized\n\n    // Find the slot that corresponds to this filament position.\n    // A slot matches if its ID equals either the config color or the XML color.\n    const slot = materialSlots.find((s) => {\n      if (!s.id.startsWith('#')) return false\n      const slotNorm = normalizeColor(s.id)\n      return slotNorm === cfgNorm || slotNorm === xmlNorm\n    })\n\n    if (!slot) continue\n\n    const newHex = resolveToHex(slot.selectedColor, colorOptions)\n    const slotNorm = normalizeColor(slot.id)\n\n    // Only add if this slot's color was actually changed\n    if (slotNorm === newHex) continue\n\n    // Add the XML basematerials color to the remap if it's not already there\n    if (!expanded.has(xmlNorm)) {\n      expanded.set(xmlNorm, newHex)\n    }\n    // Also ensure the config color is in the remap (covers the reverse mismatch)\n    if (!expanded.has(cfgNorm)) {\n      expanded.set(cfgNorm, newHex)\n    }\n  }\n\n  return expanded\n}\n\n// ---------------------------------------------------------------------------\n// Options\n// ---------------------------------------------------------------------------\n\nexport interface Export3MFOptions {\n  /**\n   * The original .3MF file. Used as the base  only color values are changed.\n   */\n  originalFile: File | Blob | ArrayBuffer\n  /**\n   * The current material slots with the user's color selections.\n   */\n  materialSlots: MaterialSlot[]\n  /**\n   * Optional color options to resolve named colors to hex.\n   * Defaults to the built-in color map.\n   */\n  colorOptions?: ColorOption[]\n  /**\n   * Output filename (without extension). Default: original filename + \"_modified\".\n   */\n  filename?: string\n}\n\n// ---------------------------------------------------------------------------\n// Core export function\n// ---------------------------------------------------------------------------\n\n/**\n * Export a modified `.3MF` file with **only** updated color values.\n *\n * Every byte of the original file is preserved except for the exact color\n * hex strings inside known color fields. No XML re-serialization, no JSON\n * reformatting. Safe for production 3D printing workflows.\n *\n * @example\n * ```ts\n * import { export3MF } from 'parse3mf/core'\n *\n * const blob = await export3MF({\n *   originalFile: myFile,\n *   materialSlots: updatedSlots,\n * })\n * ```\n */\nexport async function export3MF(options: Export3MFOptions): Promise<Blob> {\n  const { originalFile, materialSlots, colorOptions } = options\n\n  const arrayBuffer =\n    originalFile instanceof ArrayBuffer\n      ? originalFile\n      : await (originalFile as Blob).arrayBuffer()\n\n  const zip = new JSZip()\n  const zipContent = await zip.loadAsync(arrayBuffer)\n\n  // Build color remap: original (slot.id)  new hex.\n  // Only entries where the color actually changed.\n  const colorRemap = new Map<string, string>()\n  for (const slot of materialSlots) {\n    // Skip non-hex slot IDs (e.g. \"filament_1\")  these can't be\n    // matched in the raw file text.\n    if (!slot.id.startsWith('#')) continue\n\n    const originalNorm = normalizeColor(slot.id)\n    const newHex = resolveToHex(slot.selectedColor, colorOptions)\n    if (originalNorm !== newHex) {\n      colorRemap.set(originalNorm, newHex)\n    }\n  }\n\n  if (colorRemap.size === 0) {\n    // Nothing changed  return the original file byte-for-byte.\n    return new Blob([arrayBuffer], {\n      type: 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml',\n    })\n  }\n\n  // -----------------------------------------------------------------------\n  // Extract config filament colors for cross-referencing.\n  // The parser may derive slot IDs from config colors, but the model XML\n  // basematerials might have different hex values for the same filaments.\n  // We need to cover both representations in the remap.\n  // -----------------------------------------------------------------------\n  const configColors = await extractConfigFilamentColors(zipContent)\n\n  // Build a comprehensive remap that covers BOTH config-derived AND\n  // XML-derived color values (for when they differ).\n  let comprehensiveRemap = colorRemap\n\n  // -----------------------------------------------------------------------\n  // 1. Patch .model XML files\n  //    Only touches displaycolor=\"...\" on <base> elements\n  //    and color=\"...\" on <color> elements.\n  // -----------------------------------------------------------------------\n  const modelFiles = Object.keys(zipContent.files).filter(\n    (f) => f.endsWith('.model') && f.startsWith('3D/'),\n  )\n\n  for (const modelPath of modelFiles) {\n    const modelFile = zipContent.file(modelPath)\n    if (!modelFile) continue\n\n    const xml = await modelFile.async('text')\n\n    // Build an expanded remap for this model file that includes\n    // basematerials colors even if they differ from the slot IDs.\n    const modelRemap = buildModelRemap(xml, colorRemap, configColors, materialSlots, colorOptions)\n\n    // Merge any new entries back into the comprehensive remap so that\n    // config and slice_info files also benefit from the cross-reference.\n    if (modelRemap.size > colorRemap.size) {\n      comprehensiveRemap = new Map([...comprehensiveRemap, ...modelRemap])\n    }\n\n    const patched = patchModelXmlColors(xml, modelRemap)\n    if (patched !== xml) {\n      zipContent.file(modelPath, patched)\n    }\n  }\n\n  // -----------------------------------------------------------------------\n  // 2. Patch Bambu Studio project_settings.config\n  //    ONLY touches filament_colour / filament_color field values.\n  // -----------------------------------------------------------------------\n  for (const configPath of [\n    'Metadata/project_settings.config',\n    'Metadata/Project_settings.config',\n  ]) {\n    const configFile = zipContent.file(configPath)\n    if (!configFile) continue\n\n    try {\n      const content = await configFile.async('text')\n      const patched = patchProjectSettingsColors(content, comprehensiveRemap)\n      if (patched !== content) {\n        zipContent.file(configPath, patched)\n      }\n    } catch {\n      /* leave file untouched */\n    }\n  }\n\n  // -----------------------------------------------------------------------\n  // 3. Patch slice_info.config\n  //    ONLY touches color=\"...\" attributes on <filament> elements.\n  // -----------------------------------------------------------------------\n  const sliceInfoFile = zipContent.file('Metadata/slice_info.config')\n  if (sliceInfoFile) {\n    try {\n      const content = await sliceInfoFile.async('text')\n      const patched = patchSliceInfoColors(content, comprehensiveRemap)\n      if (patched !== content) {\n        zipContent.file('Metadata/slice_info.config', patched)\n      }\n    } catch {\n      /* leave file untouched */\n    }\n  }\n\n  // -----------------------------------------------------------------------\n  // 4. Patch PrusaSlicer config files\n  //    ONLY touches extruder_colour / filament_colour lines.\n  // -----------------------------------------------------------------------\n  const slicerConfigs = Object.keys(zipContent.files).filter(\n    (f) => f.includes('Slic3r') && f.endsWith('.config'),\n  )\n  for (const configPath of slicerConfigs) {\n    const configFile = zipContent.file(configPath)\n    if (!configFile) continue\n\n    try {\n      const content = await configFile.async('text')\n      const patched = patchPrusaSlicerColors(content, comprehensiveRemap)\n      if (patched !== content) {\n        zipContent.file(configPath, patched)\n      }\n    } catch {\n      /* leave file untouched */\n    }\n  }\n\n  // -----------------------------------------------------------------------\n  // 5. Re-package ZIP  let JSZip preserve original compression per file.\n  // -----------------------------------------------------------------------\n  const blob = await zipContent.generateAsync({\n    type: 'blob',\n    mimeType: 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml',\n  })\n\n  return blob\n}\n\n// ---------------------------------------------------------------------------\n// 1. Model XML: displaycolor on <base>, color on <color> elements\n//\n//    We match the ENTIRE <base .../> or <color .../> element tag and only\n//    replace the color attribute value within it. This avoids accidentally\n//    matching a \"color\" attribute on unrelated elements.\n// ---------------------------------------------------------------------------\n\nfunction patchModelXmlColors(xml: string, remap: Map<string, string>): string {\n  if (remap.size === 0) return xml\n\n  let result = xml\n\n  // <base ... displaycolor=\"VALUE\" ...>  basematerials color definitions\n  result = patchAttrInTag(result, 'base', 'displaycolor', remap)\n\n  // <color ... color=\"VALUE\" ...>  colorgroup color definitions\n  result = patchAttrInTag(result, 'color', 'color', remap)\n\n  return result\n}\n\n/**\n * Inside all occurrences of <tagName ...>, find the attribute `attrName=\"VALUE\"`\n * and replace VALUE using the color remap. Everything else is untouched.\n */\nfunction patchAttrInTag(\n  xml: string,\n  tagName: string,\n  attrName: string,\n  remap: Map<string, string>,\n): string {\n  // Match: <tagName ... attrName=\"value\" ...> (self-closing or not)\n  // We use a two-pass approach:\n  //   1. Find each <tagName ...> tag\n  //   2. Within that tag, find and replace the specific attribute value\n  const tagPattern = new RegExp(\n    `(<${tagName}\\\\b)([^>]*>)`,\n    'gi',\n  )\n\n  return xml.replace(tagPattern, (fullTag, tagOpen, rest) => {\n    // Within this tag, find attrName=\"value\" and replace the value\n    const attrPattern = new RegExp(\n      `(\\\\b${attrName}\\\\s*=\\\\s*([\"']))([^\"']*?)(\\\\2)`,\n      'gi',\n    )\n\n    const newRest = rest.replace(attrPattern, (\n      attrMatch: string,\n      prefix: string,\n      _quote: string,\n      colorVal: string,\n      closingQuote: string,\n    ) => {\n      const normalized = normalizeColor(colorVal)\n      const replacement = remap.get(normalized)\n      if (!replacement) return attrMatch\n\n      const newVal = preserveAlpha(colorVal, replacement)\n      return prefix + newVal + closingQuote\n    })\n\n    return tagOpen + newRest\n  })\n}\n\n/** Given original color value \"colorVal\" and new hex, preserve alpha suffix. */\nfunction preserveAlpha(originalVal: string, newHex: string): string {\n  const trimmed = originalVal.trim()\n  // Check if original had alpha (9 chars with #, or 8 chars without)\n  const withHash = trimmed.startsWith('#') ? trimmed : '#' + trimmed\n  if (withHash.length === 9) {\n    // Preserve the original alpha characters\n    return newHex + withHash.slice(7)\n  }\n  return newHex\n}\n\n// ---------------------------------------------------------------------------\n// 2. project_settings.config: ONLY filament_colour / filament_color fields\n//\n//    In JSON format: \"filament_colour\": [\"#FF0000FF\", \"#00FF00FF\"]\n//    In INI format:  filament_colour = #FF0000FF;#00FF00FF\n//\n//    We locate the specific field and replace colors within it only.\n// ---------------------------------------------------------------------------\n\nfunction patchProjectSettingsColors(\n  content: string,\n  remap: Map<string, string>,\n): string {\n  if (remap.size === 0) return content\n\n  const trimmed = content.trim()\n\n  if (trimmed.startsWith('{')) {\n    // JSON format  find the filament_colour/filament_color key and\n    // replace hex values within its array value only.\n    return patchJsonFilamentColors(content, remap)\n  }\n\n  // INI format  only touch the filament_colour line\n  return patchIniColorLine(content, remap)\n}\n\n/**\n * In a JSON config string, find the \"filament_colour\" (or \"filament_color\")\n * array and replace each color value. Everything else is untouched.\n */\nfunction patchJsonFilamentColors(\n  content: string,\n  remap: Map<string, string>,\n): string {\n  // Match: \"filament_colour\" : [ ... ] or \"filament_color\" : [ ... ]\n  // We capture the key + the array content.\n  const pattern = /(\"filament_colou?r\"\\s*:\\s*\\[)([^\\]]*?)(\\])/gi\n\n  return content.replace(pattern, (fullMatch, prefix, arrayContent, suffix) => {\n    // Within the array content, replace each hex color value\n    let newContent = arrayContent\n    for (const [oldHex, newHex] of remap) {\n      newContent = replaceHex(newContent, oldHex, newHex)\n    }\n    return prefix + newContent + suffix\n  })\n}\n\n/**\n * In an INI-style config, only replace colors on the filament_colour line.\n */\nfunction patchIniColorLine(content: string, remap: Map<string, string>): string {\n  return content.replace(\n    /^(filament_colou?r\\s*=\\s*)(.+)$/gim,\n    (_fullMatch, prefix, colorsLine) => {\n      let newLine = colorsLine\n      for (const [oldHex, newHex] of remap) {\n        newLine = replaceHex(newLine, oldHex, newHex)\n      }\n      return prefix + newLine\n    },\n  )\n}\n\n// ---------------------------------------------------------------------------\n// 3. slice_info.config: ONLY color=\"...\" on <filament> elements\n// ---------------------------------------------------------------------------\n\nfunction patchSliceInfoColors(\n  content: string,\n  remap: Map<string, string>,\n): string {\n  if (remap.size === 0) return content\n\n  // Match <filament ...> tags and replace color attributes within them\n  return patchAttrInTag(content, 'filament', 'color', remap)\n}\n\n// ---------------------------------------------------------------------------\n// 4. PrusaSlicer: ONLY extruder_colour / filament_colour lines\n// ---------------------------------------------------------------------------\n\nfunction patchPrusaSlicerColors(content: string, remap: Map<string, string>): string {\n  if (remap.size === 0) return content\n\n  return content.replace(\n    /^((?:extruder|filament)_colou?r\\s*=\\s*)(.+)$/gim,\n    (_fullMatch, prefix, colorsLine) => {\n      let newLine = colorsLine\n      for (const [oldHex, newHex] of remap) {\n        newLine = replaceHex(newLine, oldHex, newHex)\n      }\n      return prefix + newLine\n    },\n  )\n}\n\n// ---------------------------------------------------------------------------\n// Convenience: trigger download in the browser\n// ---------------------------------------------------------------------------\n\n/**\n * Export a modified `.3MF` and trigger a browser download.\n *\n * @example\n * ```ts\n * import { download3MF } from 'parse3mf/core'\n *\n * await download3MF({\n *   originalFile: myFile,\n *   materialSlots: updatedSlots,\n *   filename: 'my-model-recolored',\n * })\n * ```\n */\nexport async function download3MF(options: Export3MFOptions): Promise<void> {\n  const blob = await export3MF(options)\n\n  const defaultName =\n    options.originalFile instanceof File\n      ? options.originalFile.name.replace(/\\.3mf$/i, '') + '_modified'\n      : 'model_modified'\n\n  const filename = (options.filename || defaultName) + '.3mf'\n\n  const url = URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  a.download = filename\n  document.body.appendChild(a)\n  a.click()\n  document.body.removeChild(a)\n  URL.revokeObjectURL(url)\n}\n"]}